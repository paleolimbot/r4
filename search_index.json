[
["index.html", "R in the CWRS Introduction", " R in the CWRS The R Programming Group at the CWRS 2017-08-26 Introduction TODO: write this section This course material was written using the bookdown package inside RStudio. Pages were generated using pandoc and gitbook. The source is available on github. "],
["basic-r.html", "Chapter 1 Basic R 1.1 Prerequisites 1.2 Expressions and Variables 1.3 Functions 1.4 Vectors 1.5 Indexing 1.6 Excercises 1.7 Summary", " Chapter 1 Basic R When you open RStudio, you are presented with the ominous &gt; of the R console. By the end of this tutorial, hopefully that &gt; should fill you with a feeling of hope and opportunity, for magical things can happen when you type the right thing after the &gt;. This short introduction will get you started with the R console so that when we introduce more powerful functions, you can understand what R is doing at the base level! The tutorial is loosely based on the Workflow: basics tutorial in the free online book, R for Data Science. 1.1 Prerequisites To complete this tutorial, you will need R and RStudio installed, and RStudio open. If you can see the &gt; of the R console in the lower left part of your screen, you are good to go! 1.2 Expressions and Variables Let’s just do the basics: try typing in something like this at the prompt. 1 + 1 ## [1] 2 2 * 5 ## [1] 10 5 ^ 2 ## [1] 25 2 * (5 + 1) ## [1] 12 As you can see, R works just like a calculator and evaluates all of these expressions just like you would expect. If we would like to save the result of one of these expressions we can assign that value to a variable like this: x &lt;- 1 + 1 Then, to view the value of x we can just type x at the console, and R will show us the value. x ## [1] 2 The &lt;- means “assign the value on the right to the variable on the left”. We can also use x in any expression and R will substitute its value in like this: x + 2 ## [1] 4 An expression is something that R can evaluate to produce a value, like 2+2 or x + 2. Any time you type this in the console without assigning it to a variable, R will print out the value. In fact, any time you type anything into the R console, R is evaluating that expression, which may or may not return a value. If there is no value returned, R won’t print anything when you press enter. So far we’ve just used numbers, but often we need to enter text into R. Whenever we do this, we surround the text in quotes, like this: mytext &lt;- &quot;I am text&quot; Text (called strings) are one of many data types available in R. 1.3 Functions A function is some kind of operation that takes one or more arguments (input values) and produces a return value (output value). The sqrt() function is a good example: sqrt(4) ## [1] 2 Here, 4 is an argument, and the function returns the square root of that, which is 2. Functions can take more arguments, like the max function: max(2, 6, 7, 2, 10) ## [1] 10 Here we are giving the max function 5 arguments, of which it returns the maximum. One other way we specify arguments is by keyword arguments, like in the paste function. paste(&quot;string1&quot;, &quot;string2&quot;, sep = &quot;_&quot;) ## [1] &quot;string1_string2&quot; The paste function takes its arguments and combines them using the sep that we specify, in this case &quot;_&quot;. The function returns this string. Many functions in R have many many arguments and usually we only want to modify one or two of interest to us. The format is always key=value, where key is the name of the keyword and value is some expression we would like to use as the value for that argument. R contains thousands of functions that do most of what you could possibly imagine with regards to data and statistics, but remembering which one you want and how to use it can be difficult. Luckily, RStudio makes it easy using tab autocompletion and easy access to help files. To autocomplete, start typing the name of the function and press the [Tab] key (or Ctrl+Space), and RStudio will helpfully provide you with suggestions. To access the documentation for a particular function, you can type ? in front of the function name and press return, and RStudio will open the help file for you if it exists. ?paste Will bring up the following: 1.3 Description Concatenate vectors after converting to character. 1.3 Usage paste (..., sep = &quot; &quot;, collapse = NULL) paste0(..., collapse = NULL) 1.3 Arguments … one or more R objects, to be converted to character vectors. sep a character string to separate the terms. Not NA_character_. collapse an optional character string to separate the results. Not NA_character_. Note that each of these arguments can be specified by keyword, and have default values that we can see in the usage section. The ... means that we can pass any number of arguments to the function. There’s too many functions in R to keep in your head at one time, so getting good at reading these help files is very useful! 1.4 Vectors So far we’ve just been dealing with single values like 2+2 or &quot;mystring&quot;, but the real power of R is that it can operate easily on large lists of data, so it makes sense that it provides us with an easy way to work with this data. These lists of data are called vectors, and we create them using the c function (c stands for concatenate, or join together). myvector &lt;- c(10, 9, 8, 7, 2) myvector ## [1] 10 9 8 7 2 Here the c function took our arguments of 10, 9, 8, 7, and 2, and returned a vector, which we assigned to the variable named myvector. When we evaluated myvector, it printed out the list of values it contained. Vectors don’t just have to contain numbers, they can contain strings as well. mytextvector &lt;- c(&quot;word1&quot;, &quot;word2&quot;, &quot;word3&quot;) mytextvector ## [1] &quot;word1&quot; &quot;word2&quot; &quot;word3&quot; Here the c function took our arguments and returned a vector of strings, which we assigned to the variable mytextvector. It is common to have to generate a vector of all the integer values between two numbers, so R provides a short form for this: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 20:12 ## [1] 20 19 18 17 16 15 14 13 12 myothervector &lt;- 13:16 myothervector ## [1] 13 14 15 16 You can also use an expression on either side of the :, like this: (5^2):(3*10) ## [1] 25 26 27 28 29 30 start &lt;- 25 end &lt;- start + 5 start:end ## [1] 25 26 27 28 29 30 1.5 Indexing Now we’ve created vectors, but to get at what’s inside them we need to retrieve values using an index. We do this using square brackets like this: myvector &lt;- c(10, 9, 8, 7, 2) myvector[1] ## [1] 10 myvector[5] ## [1] 2 myvector[3] ## [1] 8 This code creates a vector, assigns it to the variable myvector, then retrieves the 1st, 5th, and 3rd value stored in that vector. If we would like multiple values from the vector, we can pass multiple values as indices, like this: myvector[c(1, 5, 3)] ## [1] 10 2 8 You’ll notice that the index that we’re using is actually a vector itself! I know, we’re using a vector to index a vector and it’s a little trippy, but it’s incredibly useful. You’ll remember that we can easily create vectors of sequential integers, which we can use to get a sequence of values from a vector by using it as an index. myvector[1:3] ## [1] 10 9 8 This would be equivalent to: myvector[c(1, 2, 3)] ## [1] 10 9 8 There is one other useful way to index a vector using a vector, which is to use a TRUE/FALSE vector. This is probably the most useful of the indexing methods, because it allows you to do things like: myvector[myvector == 8] ## [1] 8 This works because myvector == 8 is, itself, a TRUE/FALSE vector with the same length as myvector, indicating whether or not it equals 8 at any given position. myvector == 8 ## [1] FALSE FALSE TRUE FALSE FALSE 1.6 Excercises To practice the basics of R, complete the very first swirl module, R Programming / Basic Building Blocks. To do this, you’ll need to install and load swirl like this: install.packages(&quot;swirl&quot;) library(swirl) swirl() You should get a friendly greeting that will prompt you to choose a course (you want number 1, “R Programming: The basics of programming in R”) and a module (you want number 1, “Basic Building Blocks”). 1.7 Summary In this lesson we covered expressions, variables, functions, vectors, and indexing, all of which will help you get the most out of the tutorials in this series. For more information, check out the Workflow: basics tutorial in the free online book, R for Data Science. "],
["filtering-subsetting-and-summarising-using-dplyr.html", "Chapter 2 Filtering, Subsetting, and Summarising using dplyr 2.1 Prerequisites 2.2 Viewing a Data Frame 2.3 Selecting Columns 2.4 Filtering Rows 2.5 Selecting and Filtering 2.6 The Pipe (%&gt;%) 2.7 Summary", " Chapter 2 Filtering, Subsetting, and Summarising using dplyr 2.1 Prerequisites The prerequisites for this tutorial are tidyverse and rclimateca. If these packages aren’t installed, you’ll have to install them using install.packages(). install.packages(&quot;tidyverse&quot;) install.packages(&quot;rclimateca&quot;) Load the packages when you’re done! If there are errors, you may have not installed the above packages correctly! library(tidyverse) ## Loading tidyverse: ggplot2 ## Loading tidyverse: tibble ## Loading tidyverse: tidyr ## Loading tidyverse: readr ## Loading tidyverse: purrr ## Loading tidyverse: dplyr ## Conflicts with tidy packages ---------------------------------------------- ## filter(): dplyr, stats ## lag(): dplyr, stats library(rclimateca) Finally, you will need to obtain the sample data using the getClimateData() function in the rclimateca package. Copy/paste the statement below to load the sample data for this tutorial. climate_data &lt;- getClimateData(c(27141, 6354), nicenames = TRUE) ## | | | 0% | |================================ | 50% | |=================================================================| 100% 2.2 Viewing a Data Frame In RStudio’s “Environment” tab (usually at the top right of the screen), you should see a variable called climate_data in the list. You can inspect it by clicking on the variable name, after which a tab will appear displaying the contents of the variable you just loaded. Clicking the little arrow to the left of the name will display the structure of the data frame, including the column names and some sample values. You can also do both of these things using the R commands View() and str(), respectively. Also useful is the head() function, which will display the first few rows of a data frame. View(climate_data) # will display a graphic table browser str(climate_data) # will display a text summary of the object ## &#39;data.frame&#39;: 997 obs. of 27 variables: ## $ stationid : num 27141 27141 27141 27141 27141 ... ## $ datetime : chr &quot;1996-07&quot; &quot;1996-08&quot; &quot;1996-09&quot; &quot;1996-10&quot; ... ## $ year : int 1996 1996 1996 1996 1996 1996 1997 1997 1997 1997 ... ## $ month : int 7 8 9 10 11 12 1 2 3 4 ... ## $ meanmaxtemp : num 23.8 24.8 18.8 12.3 6.1 4.8 -0.8 -0.2 1.1 7.1 ... ## $ meanmaxtempflag : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ meanmintemp : num 14.4 13.8 11.3 3.7 0 -1.9 -9.5 -8.4 -6.9 -1.2 ... ## $ meanmintempflag : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ meantemp : num 19.1 19.4 15.1 8 3 1.5 -5.2 -4.3 -2.9 2.9 ... ## $ meantempflag : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ extrmaxtemp : num 29.6 31.6 27.6 20.4 19 15.5 10.9 10.6 10 14.4 ... ## $ extrmaxtempflag : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ extrmintemp : num 10.7 8.5 3.7 -1.7 -8.7 -15.7 -20.9 -17.1 -17 -11.7 ... ## $ extrmintempflag : chr &quot;S&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ totalrain : num NA NA NA NA NA NA NA NA NA NA ... ## $ totalrainflag : chr NA NA NA NA ... ## $ totalsnow : num NA NA NA NA NA NA NA NA NA NA ... ## $ totalsnowflag : chr NA NA NA NA ... ## $ totalprecip : num 147.5 24.4 260.7 95.5 91.3 ... ## $ totalprecipflag : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ snowgrndlastday : int 0 0 0 0 NA 0 2 4 11 0 ... ## $ snowgrndlastdayflag: chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ dirofmaxgust : int NA NA NA NA NA NA NA NA NA NA ... ## $ dirofmaxgustflag : chr NA NA NA NA ... ## $ spdofmaxgust : chr NA NA NA NA ... ## $ spdofmaxgustflag : chr NA NA NA NA ... ## $ parseddate : Date, format: &quot;1996-07-01&quot; &quot;1996-08-01&quot; ... head(climate_data) ## # A tibble: 6 x 27 ## stationid datetime year month meanmaxtemp meanmaxtempflag meanmintemp ## * &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 27141 1996-07 1996 7 23.8 14.4 ## 2 27141 1996-08 1996 8 24.8 13.8 ## 3 27141 1996-09 1996 9 18.8 11.3 ## 4 27141 1996-10 1996 10 12.3 3.7 ## 5 27141 1996-11 1996 11 6.1 0.0 ## 6 27141 1996-12 1996 12 4.8 -1.9 ## # ... with 20 more variables: meanmintempflag &lt;chr&gt;, meantemp &lt;dbl&gt;, ## # meantempflag &lt;chr&gt;, extrmaxtemp &lt;dbl&gt;, extrmaxtempflag &lt;chr&gt;, ## # extrmintemp &lt;dbl&gt;, extrmintempflag &lt;chr&gt;, totalrain &lt;dbl&gt;, ## # totalrainflag &lt;chr&gt;, totalsnow &lt;dbl&gt;, totalsnowflag &lt;chr&gt;, ## # totalprecip &lt;dbl&gt;, totalprecipflag &lt;chr&gt;, snowgrndlastday &lt;int&gt;, ## # snowgrndlastdayflag &lt;chr&gt;, dirofmaxgust &lt;int&gt;, dirofmaxgustflag &lt;chr&gt;, ## # spdofmaxgust &lt;chr&gt;, spdofmaxgustflag &lt;chr&gt;, parseddate &lt;date&gt; It’s worth mentioning a little bit about what this data frame contains, since we’ll be working with it for the rest of this tutorial. Each row contains a number of parameters that are available on a monthly basis from two Environment Canada climate stations (Kentville Agricultural Research Station is 27141; Greenwood Station is 6354). The stationid column identifies where the values were measured, the year and month column identify when the values were measured, and the rest of the columns contain the measured values. For each measured value column, there is a flag column that gives additional information about the measurement (for the most part, we will ignore these columns). The only column names that are slightly cryptic are extrmaxtemp and extrmintemp, which are the extreme maximum and minimum temperatures measured in that month, respectively. 2.3 Selecting Columns One way to subset climate_data is to subset by column, for which we will use the select() function. For example, we may only be interested in the mean temperature information, represented by the columns stationid, year, month, and meantemp. mean_temp_data &lt;- select(climate_data, stationid, year, month, meantemp) The first argument to the select() function is the original data frame (in this case, climate_data), and the remaining arguments are the names of the columns to be selected. To select the stationid, year, month, meantemp and totalprecip columns, you would use the following R command: temp_precip_data &lt;- select(climate_data, stationid, year, month, meantemp, totalprecip) 2.3.1 Excercises Use View(), str(), and head() to preview the two data frames we just created. Do they have the columns you would expect? Use select() to select stationid, year, month, and all of the columns containing temperature values, and assign it to the variable temp_data. 2.4 Filtering Rows Another way to subset climate_data is by filtering rows using column values, similar to the filter feature in Microsoft Excel. This is done using the filter() function. For example, we may only be interested in July temperature for the two stations. july_data &lt;- filter(climate_data, month == 7) Just like select(), the first argument to filter() is the original data frame, and the subsequent arguments are the conditions that each row must satisfy in order to be included in the output. Column values are referred to by the column name (in the above example, month), so to include all rows where the value in the month column is 7, we use month == 7. Passing multiple conditions means each row must satisfy all of the conditions, such that to obtain the data for July of 1999, we can use the following call to filter(): july_1999_data &lt;- filter(climate_data, month == 7, year == 1999) It is very important that there are two equals signs within filter()! The == operator tests for equality (e.g. (2 + 2) == 4), whereas the = operator assigns a value or passes a named argument to a function, which is not what you’re trying to do within filter(). Other common operators that are useful within filter are != (not equal to), &gt; (greater than), &lt; (less than), &gt;= (greater than or equal to), &lt;= (less than or equal to), and %in% (tests if the value is one of several values). Using these, we could find out which observations had mean temperatures that were below freezing: freezing_observations &lt;- filter(climate_data, meantemp &lt; 0) We could also find which observations occurred during the summer months (May, June, July, or August): summer_data &lt;- filter(climate_data, month %in% c(5, 6, 7, 8)) 2.4.1 Exercises Use View(), str(), and head() to preview the data frames we just created. Do they have the rows you would expect? Use filter() to find observations from the month of December where the mean temperature was above freezing. Are there any observations from the month of January where the mean temperature was below freezing? Filter climate_data to include only observations from the months of December, January, February, and March and assign it to a variable name of your choosing. 2.5 Selecting and Filtering Often we need to use both select() and filter() to obtain the desired subset of a data frame. To do this, we need to pass the result of select() to filter(), or the result of filter() to select. For example, we could create a data frame of mean temperature observations from the month of July one of two ways (you’ll recall that we selected temperature columns in the data frame mean_temp_data, and we filtered for the month of July in the data frame july_data): july_temp &lt;- filter(mean_temp_data, month == 7) july_temp2 &lt;- select(july_data, stationid, year, month, meantemp) 2.5.1 Exercises Inspect july_temp and july_temp2 using View(), str(), and head(). Are they identical? Create a data frame of July total precipitation data and give it a variable name of your choosing. Do this by using select() followed by filter(), then using filter() followed by select(). Inspect the output to ensure the data frames are identical. 2.6 The Pipe (%&gt;%) There is an easier way! Instead of creating intermediary variables every time we want to subset a data frame using select() and filter(), we can use the pipe operator (%&gt;%) to pass the result of one function call to another. Thus, creating our july_temp data frame from above becomes one line with one variable assignment instead of two. july_temp3 &lt;- climate_data %&gt;% filter(month == 7) %&gt;% select(stationid, year, month, meantemp) What %&gt;% does is pass the left side into the first argument of the function call on the right side. Thus, filter(climate_data, month == 7) becomes climate_data %&gt;% filter(month ==7). When using the tidyverse family of packages, you should use the pipe as often as possible! It usually makes for more readable, less error-prone code, and reduces the number of temporary variables you create that clutter up your workspace. When using filter() and select() with other tidyverse manipulations like arrange(), group_by(), summarise(), and mutate(), the pipe becomes indispensable. 2.6.1 Exercises Inspect july_temp3 to ensure it is identical to july_temp. Create a data frame of July total precipitation data using climate_data, filter(), select(), and %&gt;%. Is it identical to the data frame you created in the exercise above? 2.7 Summary In this tutorial we introduced the use of select(), filter() and the pipe (%&gt;%). These functions are the building blocks of powerful tools in the tidyverse such as group_by(), summarise(), arrange(), mutate() and many others. "],
["using-rstudio-projects.html", "Chapter 3 Using RStudio Projects 3.1 Prerequisites 3.2 Projects 3.3 Creating a new project 3.4 Organizing a project 3.5 Why use a project? 3.6 Summary", " Chapter 3 Using RStudio Projects Even if you know how to code in R, you will still need a strategy of how to organize your data, code, and output to take advantage of all the things R and RStudio have to offer. This tutorial suggests one way of doing this, with the take home message that you should stay organized! 3.1 Prerequisites The only prerequisite for this tutorial is RStudio. This tutorial draws heavily on the Projects chapter and the Scripts chapter in R for Data Science by Hadley Wickham. 3.2 Projects Projects are a notion in RStudio that let you keep a set of related data and scripts organized in a single directory. R scripts are rarely useful without data files, and data files are rarely useful on their own when using R for data analyis. Furthermore, the figures and tables you generate using R are only replicable if you know which script created them! An RStudio project lets you keep your data, scripts, and output in the same working directory, so that it is easy to refer to your data from your files, and easy to know which scripts generated your analysis. 3.3 Creating a new project To create a new project, chose New project… from the File menu, or click on the little RStudio icon in the upper right side of your screen to open the New project dialog. The project menu in RStudio is located in the upper right corner of the screen. When you have created more projects, you can easily switch between them here. This will direct you to a dialog that gives you some options about how to create your RStudio project. If you already have a folder that contains your scripts and/or data, you can use the Existing Directory option to turn that directory into a project. To create a brand new directory that is an RStudio project, choose the New Directory option. This will give you another menu, from which you’ll want to choose Empty Project. This will give you a window with a few options about where to create your project. Creating an RStudio project requires a directory name and a place where that directory lives. Name the project something descriptive and put it somwhere you can find it! The Desktop is not a bad place to start (you can move projects around after you’ve created them). 3.4 Organizing a project Most projects have at least three components: data, scripts, and output (once you get to using R Markdown you might have a fourth, documents). A well-organized project has defined places where these things live. I tend to put raw data (data that I have never touched, which usually means it is from an instrument or the internet or from somebody else’s spreadsheet) in a folder called raw_data/, and cleaned data in a folder called data/. Scripts (.R files) can live in a folder called scripts/, and output can live in a folder called output/ or figures/. R Markdown files (documents) need to live in the main project directory for a very good reason that you will learn when we get to using R Markdown. The point is not that you need to or should have specific folders, but that it is clear to you and others where to look for the various components of your project. A directory structure for a recent project collecting Halifax Water DOC measurements. The raw data folder contains an excel sheet from Halifax Water, and the clean_data.R script reads the excel sheet and generates halifax_wq.csv, which is read by all the scripts that do analysis and generate figures within the project. 3.5 Why use a project? The main advantage of using a project is that the working directory when you open one is automatically set to the directory of the project. This means that you never have to call setwd(), since your data always lives fairly close to your R script. In the above example of a recent RStudio project, hw_toc_plot.R reads in halifax_wq.csv using the command read_csv(&quot;data/halifax_wq.csv&quot;). No matter where the project lives on the computer (or indeed, whose computer the project lives on), this script can remain unchanged. This gives you the freedom to move the project folder about your computer, or to have it live somewhere like Dropbox or GitHub such that the project can be shared with others. 3.6 Summary This tutorial suggested one method of organizing R scripts and data to leverage the full potential of R and RStudio. Projects are an easy way to collect data, scripts, and output together in the same folder so that output can be replicated and analysis in scripts can be easily regenerated by yourself and others. "]
]
